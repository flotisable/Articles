#+TITLE: Makefile 簡介
#+AUTHOR: Flotisable
#+DATE: <2019-02-12 週二>
#+OPTIONS: toc:nil creator:t num:nil
#+LATEX_HEADER: \usepackage{CJKutf8}
#+LATEX_HEADER: \AtBeginDocument{ \begin{CJK}{UTF8}{bkai} }
#+LATEX_HEADER: \AtEndDocument{ \clearpage \end{CJK} }

#+LATEX: \newpage

有鑑於實驗室有些同學跟學弟不知道怎麼用 makefile，
因為個人覺得很好用，
所以就雞婆的想來介紹一下。
-----
* Makefile 是什麼
  makefile 是對 make 這種程式所讀取的檔案的統稱，
  常被用於程式建置( build )的自動化。
  但 makefile 並不只能用在程式原始碼上，
  就算是一般的檔案也沒問題。
  make 程式本質上是依據 makefile 所描述的規則，
  對於一個 *目標* 在 *什麼條件* 下要 *做什麼* 。
  所以只要需要依據一定條件做事，
  就可以利用 makefile 做自動化。
  比如說，我們在寫完一份報告後，
  要將報告相關的檔案壓成 zip 檔。
  那麼這個 zip 檔就是我們的目標，
  而條件就是報告被修改，
  要做的事就是壓縮檔案。
  
  make 程式有不同變體，
  在這篇文章中，我只會介紹 [[https://www.gnu.org/software/make][GNU make]] 這個我比較熟悉的 make。
  至於例子，因為我比較習慣用在 c++ 專案中，
  所以會以 c++ 編譯的例子為主。
* 基本使用
  就像前面提過的，makefile 中主要是描述一些規則( rule )。
  每個規則都是由下列三個項目所組成

  - 目標( target )

    要被產生的檔案。

  - 條件( prerequisite )

    可以是檔案或是其他目標。
    條件可以是空的。

  - 步驟( recipe )

    基本上是 shell 中的指令。
    
  其語法為

  #+BEGIN_SRC makefile
    target: prerequisite
      recipe
  #+END_SRC
  
  這個規則所描述的是：
  當 *目標* 不存在，或是當 *條件* 發生改變時，
  就根據 *步驟* 來產生 *目標* 。
  
  在 c++ 中常見的例子是一個目的檔在原始檔被修改後要重新編譯，
  假設原始碼名稱為 test.cpp，
  在 makefile 中可以寫成
  
  #+BEGIN_SRC makefile
    test.o: test.cpp
      g++ -c -o test.cpp
  #+END_SRC
  
  這樣子當 test.o 不存在或是 test.cpp 被修改後，
  make 就會根據所寫的步驟重新編譯出 test.o。
  值得一提的是，每個步驟必須由 tab 做開頭，
  不能是空白或是其他字元，一定要是 tab 才行。
  雖然有辦法對這個做設定，在這不在本篇文章所涵蓋的範圍。
  另外就是，步驟中所描述的指令預設會用系統的 shell 作執行，
  而每一行指令會是用不同的子行程做執行( 也就是各自獨立的意思 )，
  當然這也可以做設定。

  如果一行中所要描述的指令太長的話，
  可以用 =\= 來連接兩行作為一行，如以下例子

  #+BEGIN_SRC makefile
    test.o: test.cpp
      g++ -std=c++11 -O2 -c \
      -o test.cpp
  #+END_SRC
  
  而如果想要寫一些註解的話， =#= 後到該行結束為止都會是註解

  #+BEGIN_SRC makefile
    test.o: test.cpp # 這是註解
      g++ -c -o test.cpp # compile test.o
  #+END_SRC
  
  當一份 makefile 裡有多條規則時，預設會只執行第一條規則。
  可以藉由在參數指令目標來選擇要執行的規則。
  不如我們有以下 makefile

  #+BEGIN_SRC makefile
    program: test.o
      g++ -o program test.o

    test.o: test.cpp
      g++ -c -o test.o test.cpp
  #+END_SRC
  
  如果直接執行 make，make 會根據第一條規則看要不要產生 program。
  而我們可以在參數加上 test.o 來指定說要執行第二條規則。

  #+BEGIN_SRC sh
    make test.o
  #+END_SRC
  
  順帶一提，
  如果一條規則的條件是另一條規則的目標的話，
  則 make 會先去執行另一條規則，
  在執行原本的規則。
  以上面 makefile 為例，
  在執行 program 這條規則前。
  因為 test.o 是另一條規則的目標，
  所以會先看 test.o 存不存在以及 test.cpp 有沒有被修改，
  來判斷要不要重新編譯 test.o。
  然後再看 test.o 有沒有修改來判斷要不要重新編譯 program。

* 變數
** 一般變數
   有時候我們會想要修改 makefile 的一些部份，
   比如說要修改要編譯的程式名稱。
   或是想要重複使用同樣的指令片段，
   比如說編譯 c++ 原始碼的參數都一樣。
   這時候就可以使用變數。
   在設定變數時常用有兩種方式，
   利用 === 或 =:== 。
   這兩種方式的差別在於，
   用 =:== 設定會展開變數，
   而 === 則是變數被使用時才展開。
   比如

   #+BEGIN_SRC makefile
     flag  := -std=c++11
     flag1 =  ${flag} # flag1 為 ${flag}
     flag2 := ${flag} # flag2 為 -std=c++11

     test.o: test.cpp
       g++ ${flag1} -c -o test.o test.cpp # flag1 展開成 -std=c++11
   #+END_SRC
   
   我個人習慣用 =:== ，
   主要是因為使用變數時才展開變數理論上執行速度會比較慢，
   尤其是變數被大量使用時影響會比較大。
   不過 === 應該也有適用的地方，
   但我就不熟悉了。
   使用變數的方式也有兩種方式，
   一個是用 =$(= =)= 來包住變數，
   一個是用 =${= =}= 來包住變數。
   而這兩種方式基本上沒差。
   我個人習慣用 =${= =}= ，
   主要是可以跟後面介紹的函示作區別。
   
   有時候我們會想要將在變數後面加上新的值而不想覆蓋原本的值，
   這時候可以用 =+== ，
   比如

   #+BEGIN_SRC makefile
     variable1 := abc
     variable1 += def # variable1 為 abc def
   #+END_SRC
   
   有些常用的變數或是環境變數習慣上會用全部大寫表示，
   下面為一個使用例子

   #+BEGIN_SRC makefile
     CXX      := g++
     CXXFLAGS := -std=c++11
     LD       := g++
     LDFLAGS  :=
     PROG     := test

     ${PROG}: test.o
       ${LD} ${LDFLAGS} -o ${PROG} test.o

     test.o: test.cpp
       ${CXX} ${CXXFLAGS} -c -o test.o test.cpp
   #+END_SRC
** 自動變數
* 函數
* 其他好用功能
* 實例: 自動產生 c++ 原始碼條件
